Effective notes:
Int. В главе выделены основные библиотеки о которых будет идти речь в книге. Приведенные в книге примеры сделаны для чистоты, корректности и поддерживаемости кода в первую очередь. Терминология в большинстве случаев следует Java Language Specification, отличные примеры, такие как наследование/API и другие описаны в этой главе.
1. В этой главе описаны способы создания и удаления объектов и как это выполняется. Класс может передаваться через статические фабричные методы и/или конструктор. У первого способа есть свои плюсы: наименование методов, могут вернуть объект любого подтипа их возвращаемого типа, им необязательно создавать новый объект при их выполнении, API метода может возвращать тип интерфейса, реализация которого будет описана позднее. Ограничения применения только стат. фабричных методов: они не могут быть подклассфицированы без public/protected интерфейсов и они выделены в API не так явно как конструкторы. В главе представлены основные названия для статических фабричных методов, такие как from/of/get(new)Instance/*type* и другие.
2. В главе рассматриваются паттерны телескопического конструктора, JavaBeans и Builder. Первый возможно использовать при малом кол-ве параметров, тк каждый различный набор будет требовать свой конструктор. JavaBeans удобен в использовании, однако имеет проблемы c несогласованном состоянием во время создании, иммутабельностью и требует несколько вызовов для необязательных параметров. Паттерн Builder позволяет вызвать конструктор/статичный фабричный метод с требуемыми параметрами и через setter-like методы и метод build завершить его создание. Является хорошим выбором, если класс имеет несколько параметров, особенно если многие из них необязательные или имеют одинаковый тип.
3. Описывается применение свойства singleton в enum/private конструкторе. Синглтон - это класс, экземпляр которого создается один раз. Обычно представляет объект без состояния, такой как функция или уникален как системный компонент. Может быть реализован через public final поле или статический фабричный метод (с запросом того же поля, но private). Второй вариант имеет следующие преимущества: доступность изменения API (напр., при необходимости убрать синглтон), *Item 30* или использовании ссылки на метод как функционального интерфейса Supplier. Если данные преимущества неважны, следует использовать первый вариант. Проблемы с сериализацией может разрешить третий вариант: использование одноэлементного enum. (недоступно для класса, который наследуется не от Enum).
*При сериализации следует присвоить экземплярам тип transient и добавить метод readResolve().
4. Класс можно сделать неэкземплярным, добавив приватный конструктор с выводом ошибки. Может использоваться в классе, где поля и методы - статические. Данный класс не может иметь подклассов, т.к. у подкласса не будет доступного конструктора суперкласса для вызова.
5. Не следует использовать синглтон или статический утилити класс для реализации класса, если класс зависит от одного лии нескольких базовых ресурсов, чье поведение влияет на класс, не следует передавать эти ресурсы напрямую. Вместо этого, лучше передавать ресурсы/фабрики для их создания через конструктор (статичечную фабрику/билдер). Эта практика называется внедрением зависимостей (dependency injection).
6. 
8. Не следует использовать клинеры/финализаторы, кроме как для подстраховки или для завершения некритичных собственных ресурсов. Даже при неопределенности и последствий для производительности, это может повлечь проблемы в безопасности и скорости работы. *подробнее узнать потом
9. При использовании ресурсов, которые следует закрыть после работы с ними, следует использовать try-with-resources, ктр более прост в чтении, чем блок try-finally и обычно обходит второй в производительности. Ресурс, используемый в try-finally должен реализовывать интерфейс AutoCloseable, который имеет елинственный метод close() для закрытия ресурса.
10. Глава посвящена контракту класса с методом equals(). Иногда equals() не стоит переопределять, а именно в случаях: каждый экземпляр класса уникален по своей сути(напр., потоки), метод не должен выполнять проверку на "логическую эквивалентность" для класса (regex класса Pattern), суперкласс уже переопределил equals() нужным образом (AbstractSet/AbstractList) и т.д., метод не будет вызван (можно переписать с выбросом ошиьки). Переопределение же equals() следует выполнять в классах, в которых представлены различные значения например, типов Integer/String/etc., класс имеет понятие логического равенства, которое отличается от простого тождества объектов, и суперкласс не еще не переопределил equals. В главе рассматриваются пять требований контракта equals: рефлективность, симметричность, транзитивность, консистентность и "недействительность". Рассмотрены проблемы выполнения данных требований и примеры их ненамеренного несоблюдения. Для соблюдения консистентности важно, чтобы equals() не зависел от ненадежных ресурсов, а именно в данном методе следует выполнять только детерминированные вычисления над объектами, хранящимися в памяти. Для транзитивности приведен пример нарушения контракта в смешанных коллекциях с объектами Timestamp и Date. Общая структура метода: 1) оператор сравнения к сравниваемому объекту -> 2) instanceof оператор на сравнение корректного типа -> 3) каст аргумента к корректному типу -> 4) сравнение каждого "значимого" поля класса с теми же полями сравниваемого объекта (для примитивов ==, для объектов - equals).
11. При переопределение метода equals() всегда следует переопределять метод hashCode(). У контракта hashCode есть три правила: метод всегда должен возвращать одно и то же значение до изменения состояния экземпляра объекта, два одинаковых экземпляра объекта должны иметь одинаковое значение, возвращаемое методом и два разных экземпляра могут иметь одно значение, возвращаемое методом, но это ухудшает производительность работы с коллекциями и желательно этого избегать. Хорошая хэш-функция имеет тенденцию возвращать различные значения хэшкода для отличающихся экземпляров. Хэшкод поля класса можно получить с помощью метода Type*.hashcode(*field*). Следует использовать в функции все значимые поля класса для избежания коллизий. Стандартная хэш-функция имеет структуру result = hashCode(field) для первого значимого поля и result = 31 * result + hashcode(field) для каждого поля после первого. Возможно применение метода Objects.hash() c перечислением всех полей, но это ухудшит производительность программы. Для массивов следует выделить все значимые элементы или использовать метод Arrays.hashcode(), если все элементы значимы. Если поле значения равно null, следует использовать 0 или другую установленную константу. Если в массиве нет значимых элементов следует использовать установленную константу не равную 0. Не следует предоставлять подробную спецификацию для значения, возвращаемого hashCode, чтобы клиенты не могли обоснованно зависеть от него; это дает возможность гибко изменять его.
12. Перезапись метода toString не так критична, как перезапись метода hashCode, но делает класс более удобным в использовании и упрощает отладку систем, использующих этот класс. На практике, toString должен возвращать всю значимую информацию об объекте. В случае если это непрактично или нежелательно выводить большой объем информации, toString может использоваться для вывода общей информации об объекте. 
13*. Метод clone позволяет ... Стоит отметить, что иммутабельные классы никогда не должны предоставлять метод клонирования, поскольку это лишь поощряет нерациональное копирование

28. Массивы и дженерики отличаются разными правилами типов. Массивы ковариантны (тип возврата может изменяться в том же направлении, что и подкласс) и вещественны (представляют тип явно), а дженерики - инварианты (коллекция одного типа не может быть подклассом коллекции любого другого типа) и стирабельны (применеяют ограничения на тип только во время компиляции и отбрасывание информации о типе элемента во время выполнения). Следовательно, массивы обеспечивают безопасность типов во время выполнения, но не во время компиляции, и наоборот для дженерики, из-за чего они не сочетаются лучшим образом. При их миксинге и получении ошибок компиляции лучше использовать дженерики.
29-30. Дженерики более безопасны и удобны в использовании, чем типы, требующие приведения в клиентском коде. При разработке новых типов следует убедиться, что они могут использоваться без таких приведений, и при возможности сделать эти типы дженериками. В случае с методами-дженериками они тоже более безопасны и просты в использовании, чем методы, требующие от клиентов явных приведений входных параметров и возвращаемых значений.
31. производитель-потребитель extends/super в wildcard'e.
32. @SafeVarargs следует использовать только в каждом методе с параметром varargs дженерика или параметризованного типа, который не может быть переопределен. Varargs-дженерики методы generic безопасны, если: не хранят ничего в массиве параметров varargs и не делают этот массив (или его клон) видимым для недоверенного кода.
34. Многие enum-перечисления не требуют явных конструкторов или членов, но другие выигрывают от того, что связывают данные с каждой константой и предоставляют методы, поведение которых зависит от этих данных. Возможно использование стратегии enum-паттерна, если некоторые (не все) константы имеют общее поведение. Enum типы более читабельны и имеют больше возможностей для реализации в сравнении с набором int констант, несмотря на неощутимую потерю в производительности и предпочтительны в использовании.
35. Метод ordinal() крайне нежелателен в использовании, если есть вероятность изменения списка констант enum-типа. Данный метод используется для таких структур как EnumSet и EnumMap. Вместо этого следует использовать атрибут при создании enum-константы и конструктора.
36. EnumSet позволяет заменить набор полей побитовых полей, которые могут использоваться для включения/выключения (бинарного изменения состояния) определенных атрибутов объекта. EnumSet позволяет опеределить набор enum-констант для дальнейшего выбора нескольких из них и применения к объекту. Пример инициализации: public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }.
37. Использование ординалов для индексации массивов редко бывает целесообразным: вместо этого следует использовать EnumMap. Если представляемое отношение является многомерным, следует использовать структуру EnumMap<..., EnumMap<...>>. Редким частным случаем использования является метод Enum.ordinal (пример в итеме 35).
38. Enum класс не может быть наследован, однако для создания связи между enum-классами может быть использован интерфейс, где оба enum класса его реализуют.
39^. Предопределнные типы аннотаций позволяют повысить качество диагностической информации, предоставляемой этими средствами. Однако следует отметить, что эти аннотации еще не стандартизированы, поэтому при смене инструментария или появлении стандарта вам, возможно, придется потрудиться.
40. Аннотацию @Override всегда следует использовать при переопределении методов суперклассов, чтобы видеть изменение поведения методов класса в коде (кроме случаев с абстрактным суперклассом и неабстрактным классом).
42. Лямбды реализуют функциональные интерфейсы и упрощают представление небольших объектов функции, позволяя улучшить читаемость кода. Тем самым, их следует использовать вместо анонимных классов, кроме случаев когда нужно создавать экземпляры типов.
43. Method references (ссылки на методы) являются альтернативой лямбдам и часто могут быть короче и лаконичнее, в таких случаях следует их использовать вместо лямбда-выражений.
44. В Java присутствуют различные функциональные интерфейсы, представленные в библиотеке java.util.Function. Основные шесть функциональных интерфейсов, решающих большую часть задач: UnaryOperator, BinaryOperator (один/два одинаковых объекта как аргументы и один на выходе), Predicate (объект на входе, boolean на выходе), Function (объект на входе, аргумент на выходе), Supplier (объект на выходе), Consumer (объект на входе). Также существуют множество вариации данных функциональных интерфейсов. Если для решения задачи можно выбрать стандартный функциональный интерфейс, то следует это сделать. Для написания своего интерфейса необходимо использовать аннотацию @FunctionalInterface.
45. Stream API позволяют облегчить выполнение массовых операций, последовательных или параллельных. Этот API предоставляет две ключевые абстракции: поток, представляющий собой конечную или бесконечную последовательность элементов данных, и конвейер потока, представляющий собой многоэтапные вычисления над этими элементами. Стримы могут иметь несколько промежуточных операторов и обязательно имеют один терминальный, возвращающий результат. Промежуточные операции стрима преобразуют один поток в другой, тип элемента которого может совпадать с входным потоком или отличаться от него. Заключительная операция выполняет окончательные вычисления над потоком, полученным в результате последней промежуточной операции операции, например, сохраняет его элементы в коллекцию, возвращает определенный элемент или коллекцию элементов. Работа стримов не начинается до тех пор, пока не будет вызвана терминальная операция. Стримы удобны для трансформации последовательности элементов, их фильтра или объединения с помощью одной операции, а также объединения в коллекции или поиске набора элементов по опрееделенному критерию, но также имеют свои недостатки. Стоит помнить, что лямбды используемые в стримах не могут изменять любые локальные переменные и могут читать только переменные, которые не будут изменены, а также не могут выбрасывать проверяемое исключение или использовать ключевые слова return в текущем методе или break/continue в текущем цикле, когда все локальные переменные и данные ключевые слова доступны в обычном блоке кода.
46. Терминальный оператор forEach один из самых наименее эффективных операторов стримов и наименее дружелюбен к ним. Пусть он и выглядит удобным по использованию аналогичных циклов for-each, данный оператор должен использоваться только для сообщения результата потокового вычисления, а не для выполнения самого вычисления. Данный оператор делает используемые объекты мутабельными и при необходимости создания коллекций, следует использовать более эффективный оператор collect(). Данный оператор имеет множество реализаций, включая самые популярные toList(), toSet(), toCollection(collectionFactory) и три реализации toMap() с 2-4 аргументами. Данные реализации позволяют преобразовать элементы из стрима в лист, сет, выбранную коллекцию или Map(HashMap(2-3)/EnumMap/TreeMap(4)). Также данный оператор имеет реализации joining()/groupingBy[Concurrent]()/ min()/max() и другие методы для работы со стримами.
47. При возврате результата публичного метода следует обратить внимание на необходимость для пользователя использования коллекций или стримов. Каждый из этих вариантов имеет свои преимущества и недостатки. Если возможно, следует дать возвожность получать и Iterable коллекции, и стримы.
48. Необходимо осторожно выполнять распараллеливание потоков. Обычно прирост производительности за счет параллелизма лучше всего проявляется в потоках над экземплярами ArrayList, HashMap, HashSet и ConcurrentHashMap; массивами; диапазонами int диапазонами; и длинными диапазонами. Цена ненадлежащего распаллилвания стрима может привести к сбою в программе или сильному уменьшению производительности. При реализации кода с использованием распаллеливающих стримов следует проверить как бы данная программа работала в реальных условиях.
49. При написании любого метода или конструктора, следует учитывать то, какие ограничения существуют на параметрах метода/конструктора. Эти ограничения следует документировать ограничения и обеспечить их соблюдение с помощью явных проверок в начале тела метода тела. Данная работа может позволит на раннем этапе выявить ограничения, предотвратив возможные ошибки и сократить время прохождения тестов на валидность.
50. Каждый раз, при написании метода/конструктора, хранящего ссылку на предоставленный клиентом объект во внутренней структуре данных, подумайте о том, является ли предоставленный клиентом объект потенциально изменяемым. При возможности следует использовать неизменяемые объекты в качестве компонентов своих объектов, чтобы не приходилось беспокоиться о защитном копировании. Если класс имеет мутабельные компоненты, которые он получает от своих клиентов или возвращает им, то он должен защитно копировать эти компоненты. Если стоимость копирования слишком высокая и класс доверяет своим клиентам, что они не будут модифицировать компоненты неправомерным образом, то защитное копирование может быть заменено документацией, разъясняющей ответственность клиента за недопустимость модификации затрагиваемых компонентов.
51. Имена методов должны соответствовать конвенции наименования методов и отражать их задачу. Не следует использовать слишком много параметров в сигнатуре методов, желательно иметь не более 4 параметров. Если многие из ваших методов превышают этот предел, то ваш API будет невозможно использовать без постоянного обращения к документации. Избежать большого числа параметров можно с помощью разделения метода на несколько методов (может привести к большом кол-ву методов, но может помочь уменьшить кол-во методов за счет увеличения ортогональности), с помощью создания helper-методов (обычно являются статическими, служат для объединения часто повторяющейся группы параметров) или использование шаблона Builder (установка обязательных параметром с дальнейшим применением необязательных). Для типов параметров следует отдавать предпочтение интерфейсов вместо классов. Также двухэлементные enum могут быть более полезны, чем boolean-параметр, т.к. он явно обозначает применение параметра и может быть расширен в дальнейшем.
52. Перегрузку методов следует делать внимательно. Как правило, лучше воздержаться от перегрузки методов с несколькими сигнатур, имеющих одинаковое количество параметров. Когда это невозможно, то следует избегать тех случаев, когда один и тот же набор параметров может быть передан с помощью перегрузок путем добавления кастов (или с помощью классов-оберток, как например метод remove интерфейса List). Если это невозможно и перегрузку необходимо реализовать (при доработке существующего класса/интерфейса), следует проследить, чтобы все перегрузки выполняли идиентичную реализацию. Если этого не сделать, то при использования этого метода может быть трудно использовать перегруженный метод и это потратит лишнее время для нахождения ошибки выполнения.
53. Varargs стоит применять, когда необходимо определить методы с переменным числом аргументов (0 или больше). Перед параметром varargs следует указывать все необходимые параметры и помнить о последствиях использования varargs для производительности. Если перегруженный метод обычно принимает малое кол-во параметров, то лучше написать специальные перегруженные методы для каждого варианта, т.к. использование varargs сказывается на производительности из-за необходимости создать массив под полученные данные.
54. Для возврата пустой коллекций не стоит возвращать null, это приводит к лишним проверкам на null-значениям и может привести к ошибке, если забыть их добавить. Один из вариантов оптимизации вывода без аллокации коллекций возврат метода Collections.emptyList() и его аналогов для сета и мапы или 0-размерный массив для массивов объектов.
55... Optional<T> следует использовать, если результат метода может не вернуть результат и из-за этого придется выполнить специальную обработку, если результат не будет возвращен.